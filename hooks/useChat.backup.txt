import { useState, useEffect, useCallback, useRef } from 'react';
import type { ChatMessage, ChatState, ChatPreferences, ChatConversation, ChatAnalytics } from '../types';
import ChatService from '../services/chatService';
import { validateFile, resizeImage } from '../utils/chatUtils';

// Type for Node.js timeout
type NodeTimeout = ReturnType<typeof setTimeout>;

export const useChat = (conversationId?: string) => {
  const [state, setState] = useState<ChatState>({
    messages: {},
    conversations: [],
    activeConversationId: null,
    currentUser: null,
    typingUsers: {},
    preferences: {
      notifications: {
        enabled: true,
        sound: 'default',
        quietHours: { start: '22:00', end: '08:00' },
        priority: true,
        desktop: true,
        email: false
      },
      accessibility: {
        highContrast: false,
        fontSize: 'medium',
        screenReader: false,
        keyboardShortcuts: true,
        colorBlindFriendly: false
      },
      privacy: {
        readReceipts: true,
        typingIndicators: true,
        onlineStatus: true,
        encryptionEnabled: false
      },
      performance: {
        messageCaching: true,
        imageCompression: true,
        lazyLoading: true,
        offlineSupport: false
      },
      language: {
        primary: 'en',
        autoTranslate: false,
        autoDetect: false
      }
    },
    cache: {},
    analytics: {
      totalMessages: 0,
      totalConversations: 0,
      avgResponseTime: 0,
      messagesByType: {},
      activeHours: {},
      sentiment: { positive: 0, negative: 0, neutral: 0 },
      topContacts: []
    }
  });

  const [isRecording, setIsRecording] = useState(false);
  const [isScreenSharing, setIsScreenSharing] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedMessages, setSelectedMessages] = useState<string[]>([]);
  
  const chatService = useRef(ChatService.getInstance());
  const mediaRecorder = useRef<MediaRecorder | null>(null);
  const screenStream = useRef<MediaStream | null>(null);
  const typingTimeout = useRef<NodeTimeout | null>(null);

  // Event handlers
  useEffect(() => {
    const service = chatService.current;

    const handleMessageSent = ({ conversationId, message }: { conversationId: string; message: ChatMessage }) => {
      setState(prev => ({
        ...prev,
        messages: prev.messages.map(conv => 
          conv.id === conversationId 
            ? { ...conv, messages: [...conv.messages, message] }
            : conv
        )
      }));
    };

    const handleMessageStatusUpdate = ({ messageId, status }: { messageId: string; status: ChatMessage['status'] }) => {
      setState(prev => ({
        ...prev,
        messages: prev.messages.map(conv => ({
          ...conv,
          messages: conv.messages.map(msg => 
            msg.id === messageId ? { ...msg, status } : msg
          )
        }))
      }));
    };

    const handleMessageEdited = ({ messageId, newContent }: { messageId: string; newContent: string }) => {
      setState(prev => ({
        ...prev,
        messages: prev.messages.map(conv => ({
          ...conv,
          messages: conv.messages.map(msg => 
            msg.id === messageId 
              ? { ...msg, content: newContent, edited: true, editedAt: new Date().toISOString() }
              : msg
          )
        }))
      }));
    };

    const handleMessageDeleted = ({ messageId, permanent }: { messageId: string; permanent: boolean }) => {
      setState(prev => ({
        ...prev,
        messages: prev.messages.map(conv => ({
          ...conv,
          messages: permanent 
            ? conv.messages.filter(msg => msg.id !== messageId)
            : conv.messages.map(msg => 
                msg.id === messageId 
                  ? { ...msg, isDeleted: true, deletedAt: new Date().toISOString() }
                  : msg
              )
        }))
      }));
    };

    const handleVoiceRecordingStarted = () => setIsRecording(true);
    const handleVoiceRecordingStopped = () => setIsRecording(false);
    const handleScreenShareStarted = ({ stream }: { stream: MediaStream }) => {
      screenStream.current = stream;
      setIsScreenSharing(true);
    };
    const handleScreenShareStopped = () => {
      screenStream.current = null;
      setIsScreenSharing(false);
    };

    // Register event listeners
    service.on('messageSent', handleMessageSent);
    service.on('messageStatusUpdate', handleMessageStatusUpdate);
    service.on('messageEdited', handleMessageEdited);
    service.on('messageDeleted', handleMessageDeleted);
    service.on('voiceRecordingStarted', handleVoiceRecordingStarted);
    service.on('voiceRecordingStopped', handleVoiceRecordingStopped);
    service.on('screenShareStarted', handleScreenShareStarted);
    service.on('screenShareStopped', handleScreenShareStopped);

    return () => {
      service.off('messageSent', handleMessageSent);
      service.off('messageStatusUpdate', handleMessageStatusUpdate);
      service.off('messageEdited', handleMessageEdited);
      service.off('messageDeleted', handleMessageDeleted);
      service.off('voiceRecordingStarted', handleVoiceRecordingStarted);
      service.off('voiceRecordingStopped', handleVoiceRecordingStopped);
      service.off('screenShareStarted', handleScreenShareStarted);
      service.off('screenShareStopped', handleScreenShareStopped);
    };
  }, []);

  // Load preferences on mount
  useEffect(() => {
    const loadPreferences = async () => {
      try {
        const preferences = await chatService.current.getPreferences();
        setState(prev => ({ ...prev, preferences }));
      } catch (error) {
        setState(prev => ({ ...prev, error: 'Failed to load preferences' }));
      }
    };

    loadPreferences();
  }, []);

  // Message operations
  const sendMessage = useCallback(async (content: string, type: ChatMessage['type'] = 'text', attachments?: any[]) => {
    if (!conversationId) return;

    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      const message: Omit<ChatMessage, 'id' | 'timestamp' | 'status'> = {
        content,
        type,
        senderId: 'user',
        senderName: 'User',
        senderType: 'admin',
        readBy: [],
        reactions: []
      };

      await chatService.current.sendMessage(conversationId, message);
    } catch (error) {
      setState(prev => ({ ...prev, error: 'Failed to send message' }));
    } finally {
      setState(prev => ({ ...prev, isLoading: false }));
    }
  }, [conversationId]);

  const editMessage = useCallback(async (messageId: string, newContent: string) => {
    try {
      await chatService.current.editMessage(messageId, newContent);
    } catch (error) {
      setState(prev => ({ ...prev, error: 'Failed to edit message' }));
    }
  }, []);

  const deleteMessage = useCallback(async (messageId: string, permanent: boolean = false) => {
    try {
      await chatService.current.deleteMessage(messageId, permanent);
      setSelectedMessages(prev => prev.filter(id => id !== messageId));
    } catch (error) {
      setState(prev => ({ ...prev, error: 'Failed to delete message' }));
    }
  }, []);

  const forwardMessage = useCallback(async (messageId: string, targetConversationId: string) => {
    try {
      await chatService.current.forwardMessage(messageId, targetConversationId);
    } catch (error) {
      setState(prev => ({ ...prev, error: 'Failed to forward message' }));
    }
  }, []);

  const scheduleMessageFunc = useCallback(async (content: string, sendAt: Date) => {
    if (!conversationId) return;

    try {
      const message: Omit<ChatMessage, 'id' | 'timestamp' | 'status'> = {
        content,
        type: 'text',
        senderId: 'user',
        senderName: 'User',
        senderType: 'admin',
        readBy: [],
        reactions: []
      };

      await chatService.current.scheduleMessage(conversationId, message, sendAt);
    } catch (error) {
      setState(prev => ({ ...prev, error: 'Failed to schedule message' }));
    }
  }, [conversationId]);

  // File operations
  const uploadFile = useCallback(async (file: File) => {
    if (!conversationId) return;

    const validation = validateFile(file);
    if (!validation.valid) {
      setState(prev => ({ ...prev, error: validation.error }));
      return;
    }

    setState(prev => ({ ...prev, isLoading: true }));

    try {
      let processedFile = file;

      // Resize image if needed
      if (file.type.startsWith('image/')) {
        const resizedBlob = await resizeImage(file, 1920, 1080, 0.8);
        processedFile = new File([resizedBlob], file.name, { type: file.type });
      }

      const url = await chatService.current.uploadFile(processedFile, conversationId);
      
      // Send message with attachment
      const attachmentMessage: Omit<ChatMessage, 'id' | 'timestamp' | 'status'> = {
        content: `Shared ${file.type.startsWith('image/') ? 'image' : 'file'}: ${file.name}`,
        type: 'file',
        senderId: 'user',
        senderName: 'User',
        senderType: 'admin',
        readBy: [],
        reactions: [],
        fileData: {
          name: file.name,
          size: file.size,
          type: file.type,
          url: url
        }
      };

      await chatService.current.sendMessage(conversationId, attachmentMessage);
    } catch (error) {
      setState(prev => ({ ...prev, error: 'Failed to upload file' }));
    } finally {
      setState(prev => ({ ...prev, isLoading: false }));
    }
  }, [conversationId, sendMessage]);

  // Voice operations
  const startVoiceRecording = useCallback(async () => {
    try {
      const recorder = await chatService.current.recordVoice();
      if (recorder) {
        mediaRecorder.current = recorder;
      }
    } catch (error) {
      setState(prev => ({ ...prev, error: 'Failed to start voice recording' }));
    }
  }, []);

  const stopVoiceRecording = useCallback(async () => {
    if (!mediaRecorder.current) return;

    try {
      const audioBlob = await chatService.current.stopVoiceRecording(mediaRecorder.current);
      
      // Upload voice message
      const file = new File([audioBlob], `voice-${Date.now()}.wav`, { type: 'audio/wav' });
      await uploadFile(file);
      
      mediaRecorder.current = null;
    } catch (error) {
      setState(prev => ({ ...prev, error: 'Failed to stop voice recording' }));
    }
  }, [uploadFile]);

  // Screen sharing
  const startScreenShare = useCallback(async () => {
    try {
      await chatService.current.startScreenShare();
    } catch (error) {
      setState(prev => ({ ...prev, error: 'Failed to start screen sharing' }));
    }
  }, []);

  const stopScreenShare = useCallback(async () => {
    if (!screenStream.current) return;

    try {
      await chatService.current.stopScreenShare(screenStream.current);
    } catch (error) {
      setState(prev => ({ ...prev, error: 'Failed to stop screen sharing' }));
    }
  }, []);

  // Conversation operations
  const pinConversation = useCallback(async (convId: string) => {
    try {
      await chatService.current.pinConversation(convId);
    } catch (error) {
      setState(prev => ({ ...prev, error: 'Failed to pin conversation' }));
    }
  }, []);

  const archiveConversation = useCallback(async (convId: string) => {
    try {
      await chatService.current.archiveConversation(convId);
    } catch (error) {
      setState(prev => ({ ...prev, error: 'Failed to archive conversation' }));
    }
  }, []);

  const muteConversation = useCallback(async (convId: string, until?: Date) => {
    try {
      await chatService.current.muteConversation(convId, until);
    } catch (error) {
      setState(prev => ({ ...prev, error: 'Failed to mute conversation' }));
    }
  }, []);

  // Search
  const searchMessages = useCallback(async (query: string) => {
    setSearchQuery(query);
    if (!query.trim()) return [];

    setState(prev => ({ ...prev, isLoading: true }));

    try {
      const results = await chatService.current.searchMessages(query, conversationId);
      return results;
    } catch (error) {
      setState(prev => ({ ...prev, error: 'Search failed' }));
      return [];
    } finally {
      setState(prev => ({ ...prev, isLoading: false }));
    }
  }, [conversationId]);

  // Translation
  const translateMessage = useCallback(async (messageId: string, targetLanguage: string) => {
    try {
      return await chatService.current.translateMessage(messageId, targetLanguage);
    } catch (error) {
      setState(prev => ({ ...prev, error: 'Translation failed' }));
      return '';
    }
  }, []);

  // Typing indicator
  const setTyping = useCallback((isTyping: boolean) => {
    setState(prev => ({ ...prev, isTyping }));
    
    if (isTyping) {
      // Clear existing timeout
      if (typingTimeout.current) {
        clearTimeout(typingTimeout.current);
      }
      
      // Set new timeout to stop typing indicator
      typingTimeout.current = setTimeout(() => {
        setState(prev => ({ ...prev, isTyping: false }));
      }, 3000);
    } else {
      if (typingTimeout.current) {
        clearTimeout(typingTimeout.current);
        typingTimeout.current = null;
      }
    }
  }, []);

  // Selection operations
  const selectMessage = useCallback((messageId: string) => {
    setSelectedMessages(prev => {
      if (prev.includes(messageId)) {
        return prev.filter(id => id !== messageId);
      } else {
        return [...prev, messageId];
      }
    });
  }, []);

  const selectAllMessages = useCallback(() => {
    const currentConversation = state.conversations.find(conv => conv.id === conversationId);
    if (currentConversation) {
      setSelectedMessages(currentConversation.messages.map(msg => msg.id));
    }
  }, [conversationId, state.conversations]);

  const clearSelection = useCallback(() => {
    setSelectedMessages([]);
  }, []);

  // Preferences
  const updatePreferences = useCallback(async (preferences: Partial<ChatPreferences>) => {
    try {
      await chatService.current.updatePreferences(preferences);
      setState(prev => ({ 
        ...prev, 
        preferences: prev.preferences ? { ...prev.preferences, ...preferences } : null 
      }));
    } catch (error) {
      setState(prev => ({ ...prev, error: 'Failed to update preferences' }));
    }
  }, []);

  // Performance metrics
  const getPerformanceMetrics = useCallback(() => {
    return chatService.current.getPerformanceMetrics();
  }, []);

  // Cleanup
  useEffect(() => {
    return () => {
      if (typingTimeout.current) {
        clearTimeout(typingTimeout.current);
      }
    };
  }, []);

  return {
    // State
    ...state,
    isRecording,
    isScreenSharing,
    searchQuery,
    selectedMessages,

    // Message operations
    sendMessage,
    editMessage,
    deleteMessage,
    forwardMessage,
    scheduleMessage: scheduleMessageFunc,

    // File operations
    uploadFile,

    // Voice operations
    startVoiceRecording,
    stopVoiceRecording,

    // Screen sharing
    startScreenShare,
    stopScreenShare,

    // Conversation operations
    pinConversation,
    archiveConversation,
    muteConversation,

    // Search
    searchMessages,

    // Translation
    translateMessage,

    // Typing
    setTyping,

    // Selection
    selectMessage,
    selectAllMessages,
    clearSelection,

    // Preferences
    updatePreferences,

    // Performance
    getPerformanceMetrics,

    // Utilities
    clearError: () => setState(prev => ({ ...prev, error: null }))
  };
};
